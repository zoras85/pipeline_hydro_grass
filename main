#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script de génération automatique du réseau hydrographique et du bassin versant principal
à partir d’un point WGS84, en utilisant ALOS AW3D30, GRASS GIS 8.4 (via OSGeo4W) et GDAL/QGIS.
Les variables et chemins sont configurables via une interface graphique Tkinter ou auto-détectés.

Auteur : Zo RASOANAIVO
Dernière modification : 12/07/2025

"""

import logging
import os
import sys
import shutil
import subprocess
from datetime import datetime
from typing import Dict, Optional

import numpy as np
import rasterio
import requests
import tkinter as tk
from tkinter import filedialog, messagebox, ttk

try:
    from pyproj import CRS, Transformer
except ImportError:
    logging.critical(
        "La bibliothèque 'pyproj' est nécessaire pour la reprojection des "
        "coordonnées Lat/Lon."
    )
    logging.critical("Veuillez l’installer avec : pip install pyproj")
    sys.exit(1)


# ------------------------------------------------------------------------------
# 1. CONFIGURATION GLOBALE DÉFAUTS (pour initialiser l’interface et le pipeline)
# ------------------------------------------------------------------------------
DEFAULT_LAT: float = -24.96798112
DEFAULT_LON: float = 47.08216428
DEFAULT_BBOX_SIZE_KM: float = 50.0
DEFAULT_SITE_NAME: str = "Mandena"
DEFAULT_EPSG_CIBLE: int = 32738
DEFAULT_NODATA_VALUE: float = -9999.0
DEFAULT_STREAM_THRESHOLD_KM2: float = 0.5
DEFAULT_DEV_MODE: bool = False  # Conserve les fichiers temporaires en mode dev

# Chemins par défaut (à adapter selon votre installation locale)
DEFAULT_GRASS_GISBASE_PATH: str = r"C:\OSGeo4W\apps\grass\grass84"
DEFAULT_QGIS_PATH: str = r"C:\Program Files\QGIS 3.40.8"
DEFAULT_OUTPUT_DIR: str = (
    r"D:\Bureau\00-D3\SWAT+_Projet_Mine\Hydro_Output_GRASS"
)
DEFAULT_TEMP_DIR: str = r"D:\TEMP_HYDRO_WORK"
DEFAULT_GRASS_DB_DIR: str = r"D:\HydroGRASS_Project\GRASSdata"

# Chemins GDAL/PROJ dérivés de DEFAULT_QGIS_PATH
DEFAULT_GDALWARP_CMD_PATH: str = (
    r"C:\Program Files\QGIS 3.40.8\bin\gdalwarp.exe"
)
DEFAULT_GDAL_DATA_PATH: str = (
    r"C:\Program Files\QGIS 3.40.8\apps\gdal\share\gdal"
)
DEFAULT_PROJ_LIB_PATH: str = r"C:\Program Files\QGIS 3.40.8\share\proj"
DEFAULT_GDAL_BIN_PATH: str = r"C:\OSGeo4W\bin"

# Clé API OpenTopography (lire depuis l’environnement)
DEFAULT_OPENTOPOGRAPHY_API_KEY: str = os.getenv(
    "OPENTOPOGRAPHY_API_KEY", ""
)

# Variables globales paramétrées par l’interface ou valeurs par défaut
GRASS_CMD: str = ""
GRASS_PYTHON_PATH_GLOBAL: str = ""
GDALWARP_CMD_GLOBAL: str = ""
GDAL_DATA_EXT_GLOBAL: str = ""
PROJ_LIB_EXT_GLOBAL: str = ""
GDAL_BIN_EXT_GLOBAL: str = ""
OPENTOPOGRAPHY_API_KEY_GLOBAL: str = ""
DEV_MODE_GLOBAL: bool = DEFAULT_DEV_MODE

# ------------------------------------------------------------------------------
# 2. INITIALISATION DU LOGGING
# ------------------------------------------------------------------------------
import logging
import sys

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)
logger.info("Logging initialisé avec succès.")

# ------------------------------------------------------------------------------
# 3. IMPORTATION DYNAMIQUE DES MODULES GRASS GIS
# ------------------------------------------------------------------------------
import sys

grass = None
gsetup = None
GrassError = None
grass_python_path_global: str = ""  # Défini par init_grass_modules()


def init_grass_modules(grass_python_path: str) -> None:
    """
    Importe dynamiquement les modules Python de GRASS GIS.

    Parameters
    ----------
    grass_python_path : str
        Chemin vers le dossier 'etc/python' de l'installation GRASS.
    """
    global grass, gsetup, GrassError, grass_python_path_global

    grass_python_path_global = grass_python_path.strip()

    # Nettoyer sys.path pour éviter les doublons
    sys.path = [
        p for p in sys.path
        if p.strip() != grass_python_path_global
    ]

    # Ajouter le chemin GRASS Python si absent
    if grass_python_path_global not in sys.path:
        sys.path.insert(0, grass_python_path_global)
        logger.info(
            "Ajout de GRASS_PYTHON_PATH à sys.path : %s",
            grass_python_path_global
        )

    try:
        import grass.script as grass_script
        import grass.script.setup as gsetup_script
        from grass.exceptions import GrassError as GrassErrorClass

        grass = grass_script
        gsetup = gsetup_script
        GrassError = GrassErrorClass

        logger.info("Modules Python de GRASS importés avec succès.")
    except ImportError as e:
        logger.critical(
            "Impossible d'importer les modules Python de GRASS : %s\n"
            "Vérifiez GRASS_PYTHON_PATH (%s) et l'installation de GRASS.",
            e, grass_python_path_global
        )
        raise EnvironmentError(f"Modules GRASS non trouvés : {e}")
    except Exception as e:
        logger.critical(
            "Erreur inattendue lors de l'importation de GRASS : %s",
            e
        )
        raise

# ------------------------------------------------------------------------------
# 4. OUTILS GÉNÉRAUX
# ------------------------------------------------------------------------------
def validate_environment(
    grass_gisbase: str,
    qgis_path: str,
    opentopo_api_key: str,
    gdalwarp_cmd: str,
    gdal_data_dir: str,
    proj_lib_dir: str,
    gdal_bin_dir: str,
) -> None:
    """
    Valide l’environnement et configure les variables globales.

    Parameters
    ----------
    grass_gisbase
        Chemin vers GRASS_GISBASE (OSGeo4W).
    qgis_path
        Chemin racine de QGIS.
    opentopo_api_key
        Clé API OpenTopography.
    gdalwarp_cmd
        Chemin vers l’exécutable gdalwarp.
    gdal_data_dir
        Répertoire GDAL_DATA.
    proj_lib_dir
        Répertoire PROJ_LIB.
    gdal_bin_dir
        Répertoire bin de GDAL.
    """
    global GRASS_CMD, GRASS_PYTHON_PATH_GLOBAL
    global GDALWARP_CMD_GLOBAL, GDAL_DATA_EXT_GLOBAL
    global PROJ_LIB_EXT_GLOBAL, GDAL_BIN_EXT_GLOBAL
    global OPENTOPOGRAPHY_API_KEY_GLOBAL

    # Assignation des variables globales
    OPENTOPOGRAPHY_API_KEY_GLOBAL = opentopo_api_key
    GDALWARP_CMD_GLOBAL = gdalwarp_cmd
    GDAL_DATA_EXT_GLOBAL = gdal_data_dir
    PROJ_LIB_EXT_GLOBAL = proj_lib_dir
    GDAL_BIN_EXT_GLOBAL = gdal_bin_dir

    # Vérification de la clé API
    if not OPENTOPOGRAPHY_API_KEY_GLOBAL:
        logger.critical("Clé API OpenTopography manquante.")
        raise EnvironmentError("Clé API OpenTopography manquante.")

    # Vérification de GRASS_GISBASE
    if not os.path.isdir(grass_gisbase):
        logger.critical(
            "GRASS_GISBASE introuvable : '%s'.", grass_gisbase
        )
        raise FileNotFoundError(f"GRASS_GISBASE introuvable : {grass_gisbase}")

    # Détermination du script batch GRASS
    osgeo4w_root = os.path.dirname(
        os.path.dirname(os.path.dirname(grass_gisbase))
    )
    candidate1 = os.path.join(osgeo4w_root, "bin", "grass84.bat")
    candidate2 = os.path.join(grass_gisbase, "bin", "grass84.bat")

    if os.path.isfile(candidate1):
        GRASS_CMD = candidate1
    elif os.path.isfile(candidate2):
        GRASS_CMD = candidate2
    else:
        logger.critical(
            "NI script batch GRASS trouvé : '%s' / '%s'.",
            candidate1, candidate2,
        )
        raise FileNotFoundError("Script batch GRASS introuvable.")

    logger.info("Script GRASS choisi : %s", GRASS_CMD)

    # Vérification du chemin Python de GRASS
    GRASS_PYTHON_PATH_GLOBAL = os.path.join(grass_gisbase, "etc", "python")
    if not os.path.isdir(GRASS_PYTHON_PATH_GLOBAL):
        logger.critical(
            "GRASS python path introuvable : '%s'.",
            GRASS_PYTHON_PATH_GLOBAL,
        )
        raise FileNotFoundError(
            f"GRASS python path introuvable :"
            f" {GRASS_PYTHON_PATH_GLOBAL}"
        )

    # Vérification des outils GDAL/PROJ
    if not os.path.isfile(GDALWARP_CMD_GLOBAL):
        logger.critical(
            "gdalwarp introuvable : '%s'.", GDALWARP_CMD_GLOBAL
        )
        raise FileNotFoundError(
            f"gdalwarp introuvable : {GDALWARP_CMD_GLOBAL}"
        )

    if not os.path.isdir(GDAL_DATA_EXT_GLOBAL):
        logger.critical(
            "GDAL_DATA introuvable : '%s'.", GDAL_DATA_EXT_GLOBAL
        )
        raise FileNotFoundError(
            f"GDAL_DATA introuvable : {GDAL_DATA_EXT_GLOBAL}"
        )

    if not os.path.isdir(PROJ_LIB_EXT_GLOBAL):
        logger.critical(
            "PROJ_LIB introuvable : '%s'.", PROJ_LIB_EXT_GLOBAL
        )
        raise FileNotFoundError(
            f"PROJ_LIB introuvable : {PROJ_LIB_EXT_GLOBAL}"
        )

    if not os.path.isdir(GDAL_BIN_EXT_GLOBAL):
        logger.critical(
            "GDAL BIN introuvable : '%s'.", GDAL_BIN_EXT_GLOBAL
        )
        raise FileNotFoundError(
            f"GDAL BIN introuvable : {GDAL_BIN_EXT_GLOBAL}"
        )

    logger.info("Environnement validé (GRASS, GDAL/PROJ, API).")

    # Import dynamique des modules GRASS
    init_grass_modules(GRASS_PYTHON_PATH_GLOBAL)


def safe_subprocess(
    cmd_args: list[str],
    env: Optional[Dict[str, str]] = None,
    timeout: int = 300,
) -> None:
    """
    Exécute une commande externe et journalise stdout/stderr.

    Parameters
    ----------
    cmd_args
        Liste des arguments de la commande.
    env
        Variables d’environnement à passer.
    timeout
        Délai avant timeout (secondes).
    """
    cmd_str = " ".join(cmd_args)
    if len(cmd_str) > 200:
        cmd_str = f"{cmd_str[:197]}..."

    logger.info("Subprocess: %s", cmd_str)

    try:
        result = subprocess.run(
            cmd_args,
            check=True,
            capture_output=True,
            text=True,
            env=env,
            timeout=timeout,
        )
        if result.stdout:
            logger.debug("STDOUT:\n%s", result.stdout)
        if result.stderr:
            logger.debug("STDERR:\n%s", result.stderr)

    except subprocess.CalledProcessError as exc:
        logger.error("Échec (code %d) : %s", exc.returncode, exc.stderr)
        raise

    except subprocess.TimeoutExpired:
        logger.error(
            "Timeout dépassé (%ds) pour %s", timeout, cmd_str
        )
        raise

    except Exception:
        logger.exception("Erreur inattendue subprocess.")
        raise

# ------------------------------------------------------------------------------
# 5. ÉTAPES DU PIPELINE HYDROLOGIQUE
# ------------------------------------------------------------------------------
def calculate_bbox_wgs84(
    lat: float, lon: float, size_km: float
) -> tuple[float, float, float, float]:
    """
    Calcule une bounding box WGS84 centrée sur (lat, lon).

    Parameters
    ----------
    lat : float
        Latitude en degrés décimaux.
    lon : float
        Longitude en degrés décimaux.
    size_km : float
        Demi-côté de la box en kilomètres.

    Returns
    -------
    west, south, east, north : tuple de float
        Coordonnées de la box en WGS84.
    """
    logger.info(
        "Calcul de la boîte englobante pour une zone de %.2f km de demi-côté...",
        size_km,
    )
    delta_lat = size_km / 111.0
    delta_lon = size_km / (111.0 * np.cos(np.radians(lat)))

    south = lat - delta_lat
    north = lat + delta_lat
    west = lon - delta_lon
    east = lon + delta_lon

    logger.info(
        "Box WGS84 calculée : Ouest=%.4f, Sud=%.4f, Est=%.4f, Nord=%.4f",
        west, south, east, north,
    )
    return west, south, east, north


def telecharger_mnt(
    bbox: tuple[float, float, float, float],
    temp_dir: str,
    api_key: str,
) -> str:
    """
    Télécharge le MNT ALOS AW3D30 pour la box spécifiée.

    Parameters
    ----------
    bbox : tuple
        (west, south, east, north) en degrés.
    temp_dir : str
        Répertoire temporaire pour stocker le fichier.
    api_key : str
        Clé API OpenTopography.

    Returns
    -------
    str
        Chemin vers le fichier GeoTIFF téléchargé.
    """
    logger.info(
        "Téléchargement du MNT : bbox %s", ", ".join(f"{c:.4f}" for c in bbox)
    )
    url = "https://portal.opentopography.org/API/globaldem"
    params = {
        "demtype": "AW3D30",
        "south": bbox[1],
        "north": bbox[3],
        "west": bbox[0],
        "east": bbox[2],
        "outputFormat": "GTiff",
        "API_Key": api_key,
    }
    out_path = os.path.join(temp_dir, "alos_raw.tif")

    try:
        response = requests.get(url, params=params, stream=True, timeout=300)
        response.raise_for_status()
        with open(out_path, "wb") as f:
            shutil.copyfileobj(response.raw, f)
        logger.info("MNT brut téléchargé : %s", out_path)
        return out_path
    except requests.RequestException as e:
        logger.error(
            "Erreur téléchargement MNT OpenTopography : %s", str(e)
        )
        raise


def pretraiter_mnt(
    raw_dem_path: str,
    temp_dir: str,
    epsg_cible: int,
    nodata_value: float,
) -> str:
    """
    Reprojette et nettoie le MNT.

    Parameters
    ----------
    raw_dem_path : str
        Chemin du GeoTIFF brut.
    temp_dir : str
        Répertoire temporaire.
    epsg_cible : int
        Code EPSG cible (projection).
    nodata_value : float
        Valeur NoData à appliquer.

    Returns
    -------
    str
        Chemin vers le GeoTIFF nettoyé et reprojeté.
    """
    logger.info("Prétraitement du MNT : reprojection et nettoyage")
    out_path = os.path.join(temp_dir, "cleaned_dem_temp.tif")
    os.makedirs(os.path.dirname(out_path), exist_ok=True)

    env = os.environ.copy()
    env["GDAL_DATA"] = GDAL_DATA_EXT_GLOBAL
    env["PROJ_LIB"] = PROJ_LIB_EXT_GLOBAL
    env["PATH"] = f"{GDAL_BIN_EXT_GLOBAL}{os.pathsep}{env.get('PATH','')}"

    cmd = [
        GDALWARP_CMD_GLOBAL,
        "-overwrite",
        "-t_srs",
        f"EPSG:{epsg_cible}",
        raw_dem_path,
        out_path,
    ]
    safe_subprocess(cmd, env=env)
    logger.info("MNT reprojeté vers : %s", out_path)

    try:
        with rasterio.open(out_path, "r+") as ds:
            arr = ds.read(1)
            mask = (arr < -100) | (arr > 10000) | np.isnan(arr)
            arr[mask] = nodata_value
            ds.write(arr, 1)
            ds.update_tags(nodata=nodata_value)
        logger.info(
            "MNT nettoyé : NoData appliqué=%s", nodata_value
        )
        return out_path
    except Exception as e:
        logger.error("Erreur nettoyage MNT rasterio : %s", e)
        raise


def initialiser_grass(
    gisdb_path: str,
    location_name: str,
    mapset_name: str,
    epsg_code: int,
) -> None:
    """
    Crée ou réutilise une localisation GRASS puis initialise Python-GRASS.

    Parameters
    ----------
    gisdb_path : str
        Répertoire root de la base GRASS.
    location_name : str
        Nom de la localisation à créer ou ouvrir.
    mapset_name : str
        Nom du mapset (typiquement PERMANENT).
    epsg_code : int
        Code EPSG pour la création de la localisation.
    """
    full_path = os.path.join(gisdb_path, location_name)

    if not os.path.isdir(full_path):
        logger.info("Création localisation GRASS : %s", full_path)
        cmd = [
            GRASS_CMD,
            "--text",
            "-c",
            f"EPSG:{epsg_code}",
            full_path,
        ]
        try:
            proc = subprocess.run(
                cmd,
                input="exit\n",
                check=True,
                capture_output=True,
                text=True,
                timeout=300,
            )
            if proc.stdout:
                logger.debug("GRASS stdout :\n%s", proc.stdout)
            if proc.stderr:
                logger.debug("GRASS stderr :\n%s", proc.stderr)
        except subprocess.CalledProcessError as e:
            logger.error("Échec création GRASS (code %d)", e.returncode)
            raise
        logger.info("Localisation créée.")
    else:
        logger.info("Localisation existante : %s", location_name)

    os.environ["GISBASE"] = os.path.dirname(
        GRASS_PYTHON_PATH_GLOBAL.replace(
            os.path.join("etc", "python"), ""
        )
    )
    os.environ["PATH"] = (
        f"{os.path.join(os.environ['GISBASE'], 'bin')}"
        f"{os.pathsep}{os.environ.get('PATH','')}"
    )

    try:
        gsetup.init(gisdb_path, location_name, mapset_name)
        logger.info("GRASS Python initialisé : %s/%s",
                    location_name, mapset_name)
    except Exception as e:
        logger.critical("Échec init GRASS Python : %s", e)
        raise


def analyse_hydro_grass(
    cleaned_dem_path: str,
    lat: float,
    lon: float,
    threshold_km2: float,
    epsg_wgs84: int,
    epsg_target: int,
) -> tuple[float, float]:
    """
    Exécute l’analyse hydrographique sous GRASS GIS et retourne
    les coordonnées du point exutoire le plus proche.
    """
    try:
        # Import et région
        logger.info("Import du MNT dans GRASS")
        grass.run_command(
            "r.in.gdal",
            input=cleaned_dem_path,
            output="dem",
            flags="o",
            overwrite=True,
        )
        grass.run_command("g.region", raster="dem", flags="p")

        # Remplissage des puits
        logger.info("Remplissage des puits")
        grass.run_command(
            "r.fill.dir",
            input="dem",
            output="dem_filled",
            direction="drain_map_for_outlet",
            overwrite=True,
        )

        # Accumulation de flux
        logger.info("Calcul de l'accumulation de flux (threshold=1)")
        grass.run_command(
            "r.watershed",
            elevation="dem_filled",
            accumulation="flow_acc",
            drainage="drain_map_for_outlet",
            threshold=1,
            overwrite=True,
        )

        # Détermination du seuil en cellules
        region = grass.parse_command("g.region", flags="g")
        ew_res = float(region["ewres"])
        ns_res = float(region["nsres"])
        cell_area = ew_res * ns_res
        seuil = max(1, int(threshold_km2 * 1_000_000 / cell_area))
        logger.info("Seuil d'accumulation : %d cellules (%.2f km²)", seuil, threshold_km2)

        # Extraction réseau hydrographique
        logger.info("Extraction du réseau hydrographique")
        grass.run_command(
            "r.stream.extract",
            elevation="dem_filled",
            accumulation="flow_acc",
            threshold=seuil,
            stream_rast="streams",
            stream_vect="rivieres_raw",
            overwrite=True,
        )
        # Vectorisation
        grass.run_command(
            "v.category",
            input="rivieres_raw",
            option="add",
            output="rivieres_cat",
            type="line",
            overwrite=True,
        )
        grass.run_command(
            "v.type",
            input="rivieres_cat",
            output="rivieres",
            from_type="line",
            to_type="line",
            overwrite=True,
        )

        # Projection du point d'entrée
        transformer = Transformer.from_crs(
            f"EPSG:{epsg_wgs84}", f"EPSG:{epsg_target}", always_xy=True
        )
        proj_x, proj_y = transformer.transform(lon, lat)
        csv_pt = os.path.join(
            os.path.dirname(cleaned_dem_path), "input_point_proj.csv"
        )
        with open(csv_pt, "w", encoding="utf-8") as f:
            f.write("x,y,name\n")
            f.write(f"{proj_x},{proj_y},input_location\n")

        # Import du point
        logger.info("Import du point projeté dans GRASS")
        grass.run_command(
            "v.in.ascii",
            input=csv_pt,
            output="input_point_proj",
            x=1,
            y=2,
            separator="comma",
            skip=1,
            overwrite=True,
        )

        # Recherche de l'exutoire le plus proche
        logger.info("Recherche de l'exutoire le plus proche")
        out = grass.read_command(
            "v.distance",
            from_="input_point_proj",
            to="rivieres",
            upload="dist,to_x,to_y",
            to_type="line",
            flags="p",
        )
        lines = out.strip().splitlines()
        if len(lines) < 2:
            raise GrassError("v.distance n'a renvoyé aucun résultat valide")
        parts = lines[1].split("|")
        out_x, out_y = float(parts[2]), float(parts[3])
        logger.info("Exutoire : (%.2f, %.2f)", out_x, out_y)

        # Délimitation bassin versant
        grass.run_command(
            "r.water.outlet",
            input="drain_map_for_outlet",
            output="main_basin",
            coordinates=[out_x, out_y],
            overwrite=True,
        )
        grass.run_command(
            "r.to.vect",
            input="main_basin",
            output="main_basin_vect",
            type="area",
            flags="s",
            overwrite=True,
        )
        logger.info("Bassin versant : 'main_basin_vect'")

        # Création du point exutoire pour SWAT+
        csv_out = os.path.join(
            os.path.dirname(cleaned_dem_path), "outlet_point_swat.csv"
        )
        with open(csv_out, "w", encoding="utf-8") as f:
            f.write("x,y,PointId,RES,INLET,ID,PTSOURCE\n")
            f.write(f"{out_x},{out_y},1,0,0,1,0\n")
        grass.run_command(
            "v.in.ascii",
            input=csv_out,
            output="outlet_point",
            x=1,
            y=2,
            separator="comma",
            skip=1,
            overwrite=True,
        )
        grass.run_command(
            "v.db.addcolumn",
            map="outlet_point",
            columns=(
                "PointId INTEGER, RES INTEGER, INLET INTEGER, "
                "ID INTEGER, PTSOURCE INTEGER"
            ),
        )
        for col, val in [
            ("PointId", "1"),
            ("RES", "0"),
            ("INLET", "0"),
            ("ID", "1"),
            ("PTSOURCE", "0"),
        ]:
            grass.run_command(
                "v.db.update",
                map="outlet_point",
                column=col,
                value=val,
            )
        logger.info("Point exutoire SWAT+ : 'outlet_point'")

        # Clip réseau
        grass.run_command(
            "v.extract",
            input="rivieres",
            type="line",
            output="rivieres_only_lines",
            overwrite=True,
        )
        grass.run_command("v.build", map="rivieres_only_lines")
        grass.run_command(
            "v.clip",
            input="rivieres_only_lines",
            clip="main_basin_vect",
            output="rivieres_clipped",
            overwrite=True,
        )
        logger.info("Réseau clipé : 'rivieres_clipped'")

        # Clip exutoire
        grass.run_command(
            "v.select",
            ainput="outlet_point",
            binput="main_basin_vect",
            output="outlet_point_clipped",
            operator="within",
            overwrite=True,
        )
        logger.info("Exutoire clipé : 'outlet_point_clipped'")

        # Masquage MNT
        grass.run_command(
            "r.mask", vector="main_basin_vect", overwrite=True
        )
        grass.run_command(
            "r.mapcalc", expression="dem_filled_masked=dem_filled", overwrite=True
        )
        grass.run_command("r.mask", flags="r", overwrite=True)
        logger.info("DEM masqué : 'dem_filled_masked'")

        return out_x, out_y

    except Exception:
        logger.exception("Erreur analyse_hydro_grass()")
        raise


def export_grass_results(output_dir: str) -> None:
    """
    Exporte les résultats GRASS vers :
      - hydro_results.gpkg (vecteurs : rivieres, exutoire, bassin)
      - MNT_decoupe_bassin_versant.tif (DEM masqué)

    Parameters
    ----------
    output_dir : str
        Répertoire de destination.
    """
    logger.info("Export GRASS vers '%s'", output_dir)

    # Préparer l’environnement GDAL/PROJ
    os.environ["GDAL_DATA"] = GDAL_DATA_EXT_GLOBAL
    os.environ["PROJ_LIB"] = PROJ_LIB_EXT_GLOBAL

    gpkg_path = os.path.join(output_dir, "hydro_results.gpkg")
    dem_path = os.path.join(
        output_dir, "MNT_decoupe_bassin_versant.tif"
    )

    # Nettoyage des anciens fichiers
    for path, desc in ((gpkg_path, "GeoPackage"), (dem_path, "GeoTIFF")):
        if os.path.exists(path):
            try:
                os.remove(path)
                logger.info("Supprimé ancien %s : %s", desc, path)
            except OSError as err:
                logger.warning(
                    "Impossible de supprimer %s : %s", desc, err
                )

    try:
        # Export du réseau hydrographique
        logger.info("Export du réseau hydrographique")
        grass.run_command(
            "v.out.ogr",
            input="rivieres_clipped",
            output=gpkg_path,
            format="GPKG",
            output_layer="rivieres",
            overwrite=True,
        )

        # Export de l'exutoire
        logger.info("Export de l'exutoire")
        grass.run_command(
            "v.out.ogr",
            input="outlet_point_clipped",
            output=gpkg_path,
            format="GPKG",
            output_layer="exutoire",
            flags="a",
            overwrite=True,
        )

        # Export du bassin versant
        logger.info("Export du bassin versant")
        grass.run_command(
            "v.out.ogr",
            input="main_basin_vect",
            output=gpkg_path,
            format="GPKG",
            output_layer="main_basin",
            flags="a",
            overwrite=True,
        )

        # Export du MNT masqué
        logger.info("Export du MNT masqué")
        grass.run_command(
            "r.out.gdal",
            input="dem_filled_masked",
            output=dem_path,
            format="GTiff",
            createopt="COMPRESS=DEFLATE,PREDICTOR=2",
            flags="c",
            overwrite=True,
        )

    except Exception:
        logger.exception("Erreur lors de l'export des résultats GRASS")
        raise

    logger.info("Export des résultats terminé")

# ------------------------------------------------------------------------------
# 6. INTERFACE GRAPHIQUE TKINTER
# ------------------------------------------------------------------------------
class PipelineConfigGUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Configuration du Pipeline Hydrologique")
        self.geometry("900x750")
        self.create_widgets()

    def create_widgets(self):
        # Cadre principal pour le défilement
        main_frame = ttk.Frame(self)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        canvas = tk.Canvas(main_frame)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(
                scrollregion=canvas.bbox("all")
            )
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Configuration des colonnes pour les labels et les entrées
        scrollable_frame.columnconfigure(1, weight=1)

        # --- Variables de contrôle Tkinter ---
        self.lat_var = tk.DoubleVar(value=DEFAULT_LAT)
        self.lon_var = tk.DoubleVar(value=DEFAULT_LON)
        self.bbox_size_km_var = tk.DoubleVar(value=DEFAULT_BBOX_SIZE_KM)
        self.site_name_var = tk.StringVar(value=DEFAULT_SITE_NAME)
        self.epsg_cible_var = tk.IntVar(value=DEFAULT_EPSG_CIBLE)
        self.nodata_value_var = tk.DoubleVar(value=DEFAULT_NODATA_VALUE)
        self.stream_threshold_km2_var = tk.DoubleVar(value=DEFAULT_STREAM_THRESHOLD_KM2)
        self.opentopography_api_key_var = tk.StringVar(value=DEFAULT_OPENTOPOGRAPHY_API_KEY)

        # Variables pour les chemins
        self.grass_gisbase_path_var = tk.StringVar(value=DEFAULT_GRASS_GISBASE_PATH)
        self.qgis_path_var = tk.StringVar(value=DEFAULT_QGIS_PATH)
        self.output_dir_var = tk.StringVar(value=DEFAULT_OUTPUT_DIR)
        self.temp_dir_var = tk.StringVar(value=DEFAULT_TEMP_DIR)
        self.grass_db_dir_var = tk.StringVar(value=DEFAULT_GRASS_DB_DIR)

        # Variables pour les chemins GDAL spécifiques (dérivés mais éditables)
        self.gdalwarp_cmd_path_var = tk.StringVar(value=DEFAULT_GDALWARP_CMD_PATH)
        self.gdal_data_path_var = tk.StringVar(value=DEFAULT_GDAL_DATA_PATH)
        self.proj_lib_path_var = tk.StringVar(value=DEFAULT_PROJ_LIB_PATH)
        self.gdal_bin_path_var = tk.StringVar(value=DEFAULT_GDAL_BIN_PATH)

        self.dev_mode_var = tk.BooleanVar(value=DEFAULT_DEV_MODE)

        row = 0

        # --- Section Paramètres Géographiques ---
        ttk.Label(
            scrollable_frame,
            text="Paramètres Géographiques",
            font=("Arial", 12, "bold"),
        ).grid(
            row=row,
            columnspan=3,
            pady=(10, 5),
            sticky="w",
        )
        row += 1
        self.create_entry(
            scrollable_frame,
            "Latitude (Degrés Décimaux) :",
            self.lat_var,
            row,
        )
        row += 1
        self.create_entry(
            scrollable_frame,
            "Longitude (Degrés Décimaux) :",
            self.lon_var,
            row,
        )
        row += 1
        self.create_entry(
            scrollable_frame,
            "Taille Boîte Englobante (km) :",
            self.bbox_size_km_var,
            row,
        )
        row += 1
        self.create_entry(
            scrollable_frame,
            "Nom du Site :",
            self.site_name_var,
            row,
        )
        row += 1
        self.create_entry(
            scrollable_frame,
            "EPSG Cible :",
            self.epsg_cible_var,
            row,
        )
        row += 1

        # --- Section Paramètres MNT et Hydrologiques ---
        ttk.Label(
            scrollable_frame,
            text="Paramètres MNT et Hydrologiques",
            font=("Arial", 12, "bold"),
        ).grid(
            row=row,
            columnspan=3,
            pady=(10, 5),
            sticky="w",
        )
        row += 1
        self.create_entry(
            scrollable_frame,
            "Valeur NoData :",
            self.nodata_value_var,
            row,
        )
        row += 1
        self.create_entry(
            scrollable_frame,
            "Seuil Cours d'eau (km²) :",
            self.stream_threshold_km2_var,
            row,
        )
        row += 1

        # --- Section Clés API ---
        ttk.Label(
            scrollable_frame,
            text="Clés API",
            font=("Arial", 12, "bold"),
        ).grid(
            row=row,
            columnspan=3,
            pady=(10, 5),
            sticky="w",
        )
        row += 1
        self.create_entry(
            scrollable_frame,
            "Clé API OpenTopography :",
            self.opentopography_api_key_var,
            row,
        )
        row += 1

        # --- Section Chemins d'Installation ---
        ttk.Label(
            scrollable_frame,
            text="Chemins d'Installation",
            font=("Arial", 12, "bold"),
        ).grid(
            row=row,
            columnspan=3,
            pady=(10, 5),
            sticky="w",
        )
        row += 1
        self.create_path_entry(
            scrollable_frame,
            "Chemin Base GRASS GIS :",
            self.grass_gisbase_path_var,
            row,
            True,
        )
        row += 1
        self.create_path_entry(
            scrollable_frame,
            "Chemin Installation QGIS :",
            self.qgis_path_var,
            row,
            True,
        )
        row += 1

        # --- Section Chemins Composants GDAL/PROJ (dérivés) ---
        ttk.Label(
            scrollable_frame,
            text="Chemins des Composants GDAL/PROJ",
            font=("Arial", 12, "bold"),
        ).grid(
            row=row,
            columnspan=3,
            pady=(10, 5),
            sticky="w",
        )
        row += 1
        self.create_path_entry(
            scrollable_frame,
            "Chemin gdalwarp.exe :",
            self.gdalwarp_cmd_path_var,
            row,
        )
        row += 1
        self.create_path_entry(
            scrollable_frame,
            "Chemin GDAL_DATA (share/gdal) :",
            self.gdal_data_path_var,
            row,
        )
        row += 1
        self.create_path_entry(
            scrollable_frame,
            "Chemin PROJ_LIB (share/proj) :",
            self.proj_lib_path_var,
            row,
        )
        row += 1
        self.create_path_entry(
            scrollable_frame,
            "Chemin Binaires GDAL (bin) :",
            self.gdal_bin_path_var,
            row,
        )
        row += 1

        # --- Section Répertoires de Travail/Sortie ---
        ttk.Label(
            scrollable_frame,
            text="Répertoires de Travail/Sortie",
            font=("Arial", 12, "bold"),
        ).grid(
            row=row,
            columnspan=3,
            pady=(10, 5),
            sticky="w",
        )
        row += 1
        self.create_path_entry(
            scrollable_frame,
            "Répertoire de Sortie des Résultats :",
            self.output_dir_var,
            row,
            True,
        )
        row += 1
        self.create_path_entry(
            scrollable_frame,
            "Répertoire de Travail Temporaire :",
            self.temp_dir_var,
            row,
            True,
        )
        row += 1
        self.create_path_entry(
            scrollable_frame,
            "Répertoire Base Données GRASS GIS :",
            self.grass_db_dir_var,
            row,
            True,
        )
        row += 1

        # --- Mode Développeur ---
        ttk.Checkbutton(
            scrollable_frame,
            text="Mode Développeur (conserver les fichiers temporaires)",
            variable=self.dev_mode_var,
        ).grid(
            row=row,
            columnspan=3,
            pady=10,
            sticky="w",
        )
        row += 1

        # --- Bouton Lancer Pipeline ---
        ttk.Button(
            scrollable_frame,
            text="Lancer le Pipeline Hydrologique",
            command=self.run_pipeline,
        ).grid(
            row=row,
            columnspan=3,
            pady=20,
        )


    def create_entry(self, parent, label_text, var, row):
        ttk.Label(parent, text=label_text).grid(row=row, column=0, sticky="w", pady=2, padx=5)
        entry = ttk.Entry(parent, textvariable=var, width=50)
        entry.grid(row=row, column=1, sticky="ew", pady=2, padx=5)

    def create_path_entry(self, parent, label_text, var, row, is_dir=True):
        self.create_entry(parent, label_text, var, row)
        browse_button = ttk.Button(parent, text="Parcourir", command=lambda: self.browse_path(var, is_dir))
        browse_button.grid(row=row, column=2, sticky="e", pady=2, padx=5)

    def browse_path(self, var, is_dir):
        if is_dir:
            path = filedialog.askdirectory()
        else:
            path = filedialog.askopenfilename()
        if path:
            var.set(path)

    def get_config_from_gui(self) -> Dict[str, any]:
        return {
            "LAT": self.lat_var.get(),
            "LON": self.lon_var.get(),
            "BBOX_SIZE_KM": self.bbox_size_km_var.get(),
            "SITE_NAME": self.site_name_var.get(),
            "EPSG_CIBLE": self.epsg_cible_var.get(),
            "NODATA_VALUE": self.nodata_value_var.get(),
            "STREAM_THRESHOLD_KM2": self.stream_threshold_km2_var.get(),
            "OPENTOPOGRAPHY_API_KEY": self.opentopography_api_key_var.get(),
            "GRASS_GISBASE": self.grass_gisbase_path_var.get(),
            "QGIS_PATH": self.qgis_path_var.get(), # Garder pour référence si besoin
            "GDALWARP_CMD": self.gdalwarp_cmd_path_var.get(),
            "GDAL_DATA_EXT": self.gdal_data_path_var.get(),
            "PROJ_LIB_EXT": self.proj_lib_path_var.get(),
            "GDAL_BIN_EXT": self.gdal_bin_path_var.get(),
            "OUTPUT_DIR": self.output_dir_var.get(),
            "TEMP_DIR": self.temp_dir_var.get(),
            "GRASS_DB_DIR": self.grass_db_dir_var.get(),
            "DEV_MODE": self.dev_mode_var.get()
        }

    def run_pipeline(self):
        """
        Lance le pipeline hydrologique dans un thread, avec une fenêtre de log.
        """
        config = self.get_config_from_gui()
        self.withdraw()

        # Fenêtre de log
        progress_win = tk.Toplevel(self)
        progress_win.title("Exécution du Pipeline")
        progress_win.geometry("600x400")
        text_widget = tk.Text(progress_win, wrap="word", width=70, height=20)
        text_widget.pack(fill="both", expand=True, padx=10, pady=10)
        text_widget.insert(tk.END, "Démarrage du pipeline…\n")
        text_widget.see(tk.END)

        # Handler pour rediriger les logs vers text_widget
        class TextHandler(logging.Handler):
            def __init__(self, widget):
                super().__init__()
                self.widget = widget
                self.setFormatter(
                    logging.Formatter(
                        "%(asctime)s [%(levelname)s] %(message)s"
                    )
                )

            def emit(self, record):
                msg = self.format(record) + "\n"
                self.widget.insert(tk.END, msg)
                self.widget.see(tk.END)
                self.widget.update_idletasks()

        handler = TextHandler(text_widget)
        logger.addHandler(handler)

        def _thread():
            temp_dir = None
            grass_db = None
            try:
                # Globals
                global DEV_MODE_GLOBAL, OPENTOPOGRAPHY_API_KEY_GLOBAL
                DEV_MODE_GLOBAL = config["DEV_MODE"]
                OPENTOPOGRAPHY_API_KEY_GLOBAL = config["OPENTOPOGRAPHY_API_KEY"]

                # Validation
                validate_environment(
                    config["GRASS_GISBASE"],
                    config["QGIS_PATH"],
                    config["OPENTOPOGRAPHY_API_KEY"],
                    config["GDALWARP_CMD"],
                    config["GDAL_DATA_EXT"],
                    config["PROJ_LIB_EXT"],
                    config["GDAL_BIN_EXT"],
                )

                # Préparation dossiers
                bbox = calculate_bbox_wgs84(
                    config["LAT"], config["LON"], config["BBOX_SIZE_KM"]
                )
                now = datetime.now().strftime("%Y%m%d_%H%M%S")
                session = f"{config['SITE_NAME']}_{now}"
                out_dir = os.path.join(config["OUTPUT_DIR"], session)
                temp_dir = os.path.join(config["TEMP_DIR"], session)
                grass_db = os.path.join(
                    config["GRASS_DB_DIR"], f"hydro_grass_db_{session}"
                )
                os.makedirs(temp_dir, exist_ok=True)
                os.makedirs(os.path.dirname(grass_db), exist_ok=True)
                os.makedirs(out_dir, exist_ok=True)
                logger.info(
                    "Dossiers créés : temp=%s db=%s out=%s",
                    temp_dir, grass_db, out_dir
                )

                # Pipeline
                dem0 = telecharger_mnt(
                    bbox, temp_dir, OPENTOPOGRAPHY_API_KEY_GLOBAL
                )
                dem1 = pretraiter_mnt(
                    dem0,
                    temp_dir,
                    config["EPSG_CIBLE"],
                    config["NODATA_VALUE"],
                )
                initialiser_grass(
                    grass_db,
                    f"hydro_loc_{session}",
                    "PERMANENT",
                    config["EPSG_CIBLE"],
                )
                # on passe 4326 directement comme EPSG source WGS84
                x_out, y_out = analyse_hydro_grass(
                    dem1,
                    config["LAT"],
                    config["LON"],
                    config["STREAM_THRESHOLD_KM2"],
                    4326,
                    config["EPSG_CIBLE"],
                )
                export_grass_results(out_dir)

                msg = f"✅ Pipeline terminé. Résultats dans : {out_dir}"
                logger.info(msg)
                messagebox.showinfo("Succès", msg)

            except Exception as e:
                logger.critical("❌ Pipeline échoué : %s", e, exc_info=True)
                messagebox.showerror(
                    "Échec du pipeline",
                    f"Le pipeline a échoué.\nDétails : {e}"
                )

            finally:
                logger.removeHandler(handler)
                progress_win.destroy()
                self.deiconify()
                if not DEV_MODE_GLOBAL:
                    for d in (temp_dir, grass_db):
                        if d and os.path.isdir(d):
                            try:
                                shutil.rmtree(d)
                                logger.info("Supprimé : %s", d)
                            except OSError as err:
                                logger.error(
                                    "Échec suppression %s : %s", d, err
                                )
                else:
                    logger.info("Mode dev : temporaires conservés.")

        import threading
        threading.Thread(target=_thread).start()

# ------------------------------------------------------------------------------
# 7. POINT D'ENTRÉE DU SCRIPT
# ------------------------------------------------------------------------------
if __name__ == "__main__":
    app = PipelineConfigGUI()
    app.mainloop()
